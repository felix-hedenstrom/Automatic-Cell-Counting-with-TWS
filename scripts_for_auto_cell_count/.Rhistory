fam.fn = "ALL_TOP_samples.fam",
out.gdsfn = "ALL_TOP_samples.gds")
snpds
browseVignettes("SNPRelate")
WDir = "C:/Users/19099/Documents/Chi_Hua_Lab/plink-1.07-dos"     # UPDATE to your file path
library(SNPRelate)
library(SNPRelate)
load("~/Chi_Hua_Lab/ALL_TOP_GENODATA.Rdata")
load("~/Chi_Hua_Lab/plink-1.07-dos/gds_workspace_with_CLZ_data.RData")
1+2
2+2
source('~/.active-rstudio-document')
v = c(0, first, pi)
v
class(v)
pres = c("George", "Washington")
class(pres)
m = matrix(c(1,2,3,4,5,6), nrow=2, ncol=3)
m
colName = c(1,2,3)
v = c(TRUE,FALSE,TRUE)
age = c(10,20,30)
disney = data.frame(colName, v, age)
View(disney)
rowName = c(15,21,32)
v = c(TRUE,FALSE,TRUE)
age = c(10,20,30)
disney = data.frame(rowName, v, age)
fib = c(1,1,2,3,5,8,13,21,34,55)
fib
fib = c(0,1,1,2,3,5,8,13,21,34)
fib
library(EnhancedVolcano)
library(readxl)
RNAseq_of_whole_blood_in_MS_patients <- read_excel("Kaul_Lab/INFB_Project/RNAseq of whole blood in MS patients.xlsx")
View(RNAseq_of_whole_blood_in_MS_patients)
library(readxl)
RNAseq_PBMC_in_IFNB_treated_MS_Patients <- read_excel("Kaul_Lab/INFB_Project/RNAseq PBMC in IFNB treated MS Patients.xlsx")
View(RNAseq_PBMC_in_IFNB_treated_MS_Patients)
install.packages("https://cran.r-project.org/src/contrib/rlang_0.4.10.tar.gz", repos = NULL, type="source")
library(readr)
Ephrin_Genes <- read_csv("Kaul_Lab/INFB_Project/Ephrin_Genes.csv")
View(Ephrin_Genes)
# Author: Theo, Tyler Jang
# Date 10/20/2021
# This file is the pipeline.....
#
###
# Method: trim_names
# Input: file names
# Output: bisected file names based on split
# Description:useful if information in automatic file name from microscope is repetitive
###
trim_names <- function(file_names, split = "_XY", half = "front"){
id1 <- file_names
sid1 <- strsplit(id1, split)
newsid1 <- NA
for (i in 1:length(sid1)){
if(half == "front") {newsid1 <- c(newsid1, tail(sid1[[i]],1))}
else if(half == "back") { newsid1 <- c(newsid1, head(sid1[[i]],1))}
else{print("half = front or back, please")
break}
}
newsid1 <- newsid1[-1]
}
###
# Method: Sep_slidebook
# Input: file names containng all relevant image info (animal #, slice #, field #)
# Output: data frame with each type of info as it own column
# Description: parses out individual grouping variables
###
sep_slidebook <- function(x, sep = "-"){
newsid1 <- x
newsid1_s <- strsplit(newsid1, sep)
#look at what elements you are working with
head(newsid1_s,3)
max_l <- length(newsid1_s[[1]])
##parseit takes a list of seperated relevent name elements from every image
parseit <-function(x,object_num){
newsid1_anum <- NA
for (i in 1:length(x)){
newsid1_anum <- c(newsid1_anum, x[[i]][object_num])
}
newsid1_anum <- newsid1_anum[-1]
}
###these are what you need to adjust for different names of images!!!!####
newsid1_anum <- parseit(x = newsid1_s, object_num = 2)
newsid1_snum <- parseit(x = newsid1_s, object_num = 3)
newsid1_fnum <- parseit(x = newsid1_s, object_num = max_l)
fnumsid1_s <- strsplit(newsid1_fnum, "") #### sometimes another seperation step is required
newsid1_fnum1 <- parseit(x = fnumsid1_s, object_num = 1)
newsid1_fnum2 <- parseit(x = fnumsid1_s, object_num = 2)
newsid1_fnum3 <- paste(newsid1_fnum1,newsid1_fnum2, sep = "") # for clarity, seperated objects can be recombined in order with paste()
####making the data frames-----------
id1_df <- cbind(newsid1_anum, newsid1_snum, newsid1_fnum3)
head(id1_df)
#return(id1_df_squish)
return(id1_df)
}
###
# Method: squish
# Input: data from of grouping variables
# Output: list of unique image IDs contining specific grouping information
# Description: creates one grouping object for each image that can be compared across other iterations of the images with slightly different file names
###
squish <- function(input_df){
id1_df_squish <- NA
for (i in 1:dim(input_df)[1]) {
id1_df_squish[i] <- paste0(input_df[i,], sep = "_", collapse = "")
}
return(id1_df_squish)
}##simple function to combine rows of the df with info
#BiocManager::install("EBImage")
library("EBImage")
#install.packages("OpenImageR") ##dotn know if one or both is neccesary yet
library("OpenImageR")
###all the file locations
id_for_in_dir <-"../training_area/Weka_Output_Thresholded/"
in_dir_list <- dir(id_for_in_dir)
file_list <- dir(paste(id_for_in_dir,"/", in_dir_list[1],"/", sep = ""))
id_for_in_dir
in_dir_list
# Author: Theo, Tyler Jang
# Date 10/20/2021
# This file is the pipeline.....
#
###
# Method: trim_names
# Input: file names
# Output: bisected file names based on split
# Description:useful if information in automatic file name from microscope is repetitive
###
trim_names <- function(file_names, split = "_XY", half = "front"){
id1 <- file_names
sid1 <- strsplit(id1, split)
newsid1 <- NA
for (i in 1:length(sid1)){
if(half == "front") {newsid1 <- c(newsid1, tail(sid1[[i]],1))}
else if(half == "back") { newsid1 <- c(newsid1, head(sid1[[i]],1))}
else{print("half = front or back, please")
break}
}
newsid1 <- newsid1[-1]
}
###
# Method: Sep_slidebook
# Input: file names containng all relevant image info (animal #, slice #, field #)
# Output: data frame with each type of info as it own column
# Description: parses out individual grouping variables
###
sep_slidebook <- function(x, sep = "-"){
newsid1 <- x
newsid1_s <- strsplit(newsid1, sep)
#look at what elements you are working with
head(newsid1_s,3)
max_l <- length(newsid1_s[[1]])
##parseit takes a list of seperated relevent name elements from every image
parseit <-function(x,object_num){
newsid1_anum <- NA
for (i in 1:length(x)){
newsid1_anum <- c(newsid1_anum, x[[i]][object_num])
}
newsid1_anum <- newsid1_anum[-1]
}
###these are what you need to adjust for different names of images!!!!####
newsid1_anum <- parseit(x = newsid1_s, object_num = 2)
newsid1_snum <- parseit(x = newsid1_s, object_num = 3)
newsid1_fnum <- parseit(x = newsid1_s, object_num = max_l)
fnumsid1_s <- strsplit(newsid1_fnum, "") #### sometimes another seperation step is required
newsid1_fnum1 <- parseit(x = fnumsid1_s, object_num = 1)
newsid1_fnum2 <- parseit(x = fnumsid1_s, object_num = 2)
newsid1_fnum3 <- paste(newsid1_fnum1,newsid1_fnum2, sep = "") # for clarity, seperated objects can be recombined in order with paste()
####making the data frames-----------
id1_df <- cbind(newsid1_anum, newsid1_snum, newsid1_fnum3)
head(id1_df)
#return(id1_df_squish)
return(id1_df)
}
###
# Method: squish
# Input: data from of grouping variables
# Output: list of unique image IDs contining specific grouping information
# Description: creates one grouping object for each image that can be compared across other iterations of the images with slightly different file names
###
squish <- function(input_df){
id1_df_squish <- NA
for (i in 1:dim(input_df)[1]) {
id1_df_squish[i] <- paste0(input_df[i,], sep = "_", collapse = "")
}
return(id1_df_squish)
}##simple function to combine rows of the df with info
#BiocManager::install("EBImage")
library("EBImage")
#install.packages("OpenImageR") ##dotn know if one or both is neccesary yet
library("OpenImageR")
###all the file locations
id_for_in_dir <-"../training_area/Weka_Output_Thresholded/"
in_dir_list <- dir(id_for_in_dir)
setwd("c:/Users/19099/Documents/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/")
# Author: Theo, Tyler Jang
# Date 10/20/2021
# This file is the pipeline.....
#
###
# Method: trim_names
# Input: file names
# Output: bisected file names based on split
# Description:useful if information in automatic file name from microscope is repetitive
###
trim_names <- function(file_names, split = "_XY", half = "front"){
id1 <- file_names
sid1 <- strsplit(id1, split)
newsid1 <- NA
for (i in 1:length(sid1)){
if(half == "front") {newsid1 <- c(newsid1, tail(sid1[[i]],1))}
else if(half == "back") { newsid1 <- c(newsid1, head(sid1[[i]],1))}
else{print("half = front or back, please")
break}
}
newsid1 <- newsid1[-1]
}
###
# Method: Sep_slidebook
# Input: file names containng all relevant image info (animal #, slice #, field #)
# Output: data frame with each type of info as it own column
# Description: parses out individual grouping variables
###
sep_slidebook <- function(x, sep = "-"){
newsid1 <- x
newsid1_s <- strsplit(newsid1, sep)
#look at what elements you are working with
head(newsid1_s,3)
max_l <- length(newsid1_s[[1]])
##parseit takes a list of seperated relevent name elements from every image
parseit <-function(x,object_num){
newsid1_anum <- NA
for (i in 1:length(x)){
newsid1_anum <- c(newsid1_anum, x[[i]][object_num])
}
newsid1_anum <- newsid1_anum[-1]
}
###these are what you need to adjust for different names of images!!!!####
newsid1_anum <- parseit(x = newsid1_s, object_num = 2)
newsid1_snum <- parseit(x = newsid1_s, object_num = 3)
newsid1_fnum <- parseit(x = newsid1_s, object_num = max_l)
fnumsid1_s <- strsplit(newsid1_fnum, "") #### sometimes another seperation step is required
newsid1_fnum1 <- parseit(x = fnumsid1_s, object_num = 1)
newsid1_fnum2 <- parseit(x = fnumsid1_s, object_num = 2)
newsid1_fnum3 <- paste(newsid1_fnum1,newsid1_fnum2, sep = "") # for clarity, seperated objects can be recombined in order with paste()
####making the data frames-----------
id1_df <- cbind(newsid1_anum, newsid1_snum, newsid1_fnum3)
head(id1_df)
#return(id1_df_squish)
return(id1_df)
}
###
# Method: squish
# Input: data from of grouping variables
# Output: list of unique image IDs contining specific grouping information
# Description: creates one grouping object for each image that can be compared across other iterations of the images with slightly different file names
###
squish <- function(input_df){
id1_df_squish <- NA
for (i in 1:dim(input_df)[1]) {
id1_df_squish[i] <- paste0(input_df[i,], sep = "_", collapse = "")
}
return(id1_df_squish)
}##simple function to combine rows of the df with info
#BiocManager::install("EBImage")
library("EBImage")
#install.packages("OpenImageR") ##dotn know if one or both is neccesary yet
library("OpenImageR")
###all the file locations
id_for_in_dir <-"../training_area/Weka_Output_Thresholded/"
in_dir_list <- dir(id_for_in_dir)
file_list <- dir(paste(id_for_in_dir,"/", in_dir_list[1],"/", sep = ""))
in_dir_list
file_list
id_for_out_dir <-"../training_area/Weka_Output_Projected/"
out_dir_list <- dir(id_for_out_dir)
id1 <- file_list
newsid1 <- trim_names(id1, half="back")
sid1
strsplit(file_names, "_XY")
strsplit(id1, "_XY")
tail(sid1[[i]],1))
id1 <- file_names
file_names = id1
split = "_XY"
half="front"
id1 <- file_names
sid1 <- strsplit(id1, split)
newsid1 <- NA
for (i in 1:length(sid1)){
if(half == "front") {newsid1 <- c(newsid1, tail(sid1[[i]],1))}
else if(half == "back") { newsid1 <- c(newsid1, head(sid1[[i]],1))}
else{print("half = front or back, please")
break}
}
newsid1 <- newsid1[-1]
newsid1
half = "back"
id1 <- file_names
sid1 <- strsplit(id1, split)
newsid1 <- NA
for (i in 1:length(sid1)){
if(half == "front") {newsid1 <- c(newsid1, tail(sid1[[i]],1))}
else if(half == "back") { newsid1 <- c(newsid1, head(sid1[[i]],1))}
else{print("half = front or back, please")
break}
}
newsid1 <- newsid1[-1]
newsid1
id1 <- file_names
sid1 <- strsplit(id1, split)
newsid1 <- NA
for (i in 1:length(sid1)){
if(half == "front") {newsid1 <- c(newsid1, tail(sid1[[i]],1))}
else if(half == "back") { newsid1 <- c(newsid1, head(sid1[[i]],1))}
else{print("half = front or back, please")
break}
}
newsid1
id1 <- file_list
newsid1 <- trim_names(id1, half="back")
id1_df_sep <- sep_slidebook(x = newsid1, sep = c("-"))
x = newsid1
sep = "-"
newsid1 <- x
newsid1_s <- strsplit(newsid1, sep)
#look at what elements you are working with
head(newsid1_s,3)
max_l <- length(newsid1_s[[1]])
max_l
##parseit takes a list of seperated relevent name elements from every image
parseit <-function(x,object_num){
newsid1_anum <- NA
for (i in 1:length(x)){
newsid1_anum <- c(newsid1_anum, x[[i]][object_num])
}
newsid1_anum <- newsid1_anum[-1]
}
###these are what you need to adjust for different names of images!!!!####
newsid1_anum <- parseit(x = newsid1_s, object_num = 2)
newsid1_anum
newsid1_s
newsid1_anum
###these are what you need to adjust for different names of images!!!!####
newsid1_anum <- parseit(x = newsid1_s, object_num = 2)
newsid1_snum <- parseit(x = newsid1_s, object_num = 3)
newsid1_fnum <- parseit(x = newsid1_s, object_num = max_l)
newsid1_snum
newsid1_fnum
fnumsid1_s <- strsplit(newsid1_fnum, "") #### sometimes another seperation step is required
fnumsid1_s
newsid1_fnum1 <- parseit(x = fnumsid1_s, object_num = 1)
newsid1_fnum2 <- parseit(x = fnumsid1_s, object_num = 2)
newsid1_fnum3 <- paste(newsid1_fnum1,newsid1_fnum2, sep = "") # for clarity, seperated objects can be recombined in order with paste()
newsid1_fnum1
newsid1_fnum3
newsid1_fnum2
id1_df <- cbind(newsid1_anum, newsid1_snum, newsid1_fnum3)
head(id1_df)
id1_df_sep <- sep_slidebook(x = newsid1, sep = c("-"))
id1_df_sep
dim(id1_df_sep)
dim(id1_df_sep)[1]
id1_df_squish
input_df
input_df = id1_df_sep
id1_df_squish <- NA
for (i in 1:dim(input_df)[1]) {
id1_df_squish[i] <- paste0(input_df[i,], sep = "_", collapse = "")
}
id1_df_squish
id1_df_squish <- squish(input_df = id1_df_sep)
big_df <- cbind(newsid1, id1_df_squish,id1_df_sep) ##specify: original file names, info columns, squished ID
big_df
View(big_df)
View(id1_df_sep)
View(id1_df)
View(input_df)
View(newsid1_s)
newsid1
id1_df_sep
id1_df_squish
id1_df_squish
id1_df_squish
length(file_list)
u_img
length(file_list)
u_img <- unique(big_df$img_ID)
length(u_img)
u_img <- unique(big_df$img_ID)
###
# Method: Sep_slidebook
# Input: file names containng all relevant image info (animal #, slice #, field #)
# Output: data frame with each type of info as it own column
# Description: parses out individual grouping variables
###
sep_slidebook <- function(x, sep = "-"){
newsid1 <- x
newsid1_s <- strsplit(newsid1, sep)
#look at what elements you are working with
head(newsid1_s,3)
max_l <- length(newsid1_s[[1]])
##parseit takes a list of seperated relevent name elements from every image
parseit <-function(x,object_num){
newsid1_anum <- NA
for (i in 1:length(x)){
newsid1_anum <- c(newsid1_anum, x[[i]][object_num])
}
newsid1_anum <- newsid1_anum[-1]
}
###these are what you need to adjust for different names of images!!!!####
newsid1_anum <- parseit(x = newsid1_s, object_num = 2)
newsid1_snum <- parseit(x = newsid1_s, object_num = 3)
newsid1_fnum <- parseit(x = newsid1_s, object_num = max_l)
fnumsid1_s <- strsplit(newsid1_fnum, "") #### sometimes another seperation step is required
newsid1_fnum1 <- parseit(x = fnumsid1_s, object_num = 1)
newsid1_fnum2 <- parseit(x = fnumsid1_s, object_num = 2)
newsid1_fnum3 <- paste(newsid1_fnum1,newsid1_fnum2, sep = "") # for clarity, seperated objects can be recombined in order with paste()
####making the data frames-----------
id1_df <- cbind(newsid1_anum, newsid1_snum, newsid1_fnum3)
head(id1_df)
#return(id1_df_squish)
return(id1_df)
}
###
# Method: squish
# Input: data from of grouping variables
# Output: list of unique image IDs contining specific grouping information
# Description: creates one grouping object for each image that can be compared across other iterations of the images with slightly different file names
###
squish <- function(input_df){
id1_df_squish <- NA
for (i in 1:dim(input_df)[1]) {
id1_df_squish[i] <- paste0(input_df[i,], sep = "_", collapse = "")
}
return(id1_df_squish)
}##simple function to combine rows of the df with info
#BiocManager::install("EBImage")
library("EBImage")
#install.packages("OpenImageR") ##dotn know if one or both is neccesary yet
library("OpenImageR")
###all the file locations
id_for_in_dir <-"../training_area/Weka_Output_Thresholded/"
in_dir_list <- dir(id_for_in_dir)
file_list <- dir(paste(id_for_in_dir,"/", in_dir_list[1],"/", sep = ""))
id_for_out_dir <-"../training_area/Weka_Output_Projected/"
out_dir_list <- dir(id_for_out_dir)
id1 <- file_list
newsid1 <- trim_names(id1, half="back")
id1_df_sep <- sep_slidebook(x = newsid1, sep = c("-"))
id1_df_squish <- squish(input_df = id1_df_sep)
big_df <- cbind(newsid1, id1_df_squish,id1_df_sep) ##specify: original file names, info columns, squished ID
colnames(big_df) <- c("file_name", "img_ID", "a_num","S_num", "F_num")
big_df <- data.frame(big_df) #this df gives us access to varibles based on the images in several forms
length(file_list)
u_img <- unique(big_df$img_ID)
length(u_img)
dim(big_df)
j = 1
rel_path = paste0(id_for_in_dir, in_dir_list[j])
rel_path
img_file_names <- list.files(path = rel_path)
img_file_names
out_loc
rel_path = paste0(id_for_in_dir, in_dir_list[j])
img_file_names <- list.files(path = rel_path)
out_loc <- out_dir_list[j]
out_loc
i = 1
##identify images belonging to each unique image ID
all_current_ID <- grep(u_img[i],big_df$img_ID)
all_current_ID
u_img[i]
big_df$img_ID
img_file_names
all_current_ID
this_group
this_group <- img_file_names[all_current_ID]
this_group
u_img[i]
big_df$img_ID
this_group
# Sum projected as equal to the number of layers in the image
projected = 0
max_len = length(this_group)
max_len
paste0(rel_path, "/", as.character(this_group[k])
)
k = 1
paste0(rel_path, "/", as.character(this_group[k])
)
# Sum projected as equal to the number of layers in the image
projected = 0
max_len = length(this_group)
for (k in 1:max_len) {
projected = projected + readImage(paste0(rel_path, "/", as.character(this_group[k])))
}
projected[projected >255] = 255
projected
View(projected)
source('~/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/Project N images by ID.R')
source('~/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/Project N images by ID.R')
source('~/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/Project N images by ID.R')
source('~/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/classifier_comparison.R')
setwd("c:/Users/19099/Documents/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/")
source('~/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/classifier_comparison.R')
getwd()
source('~/Kaul_Lab/AutoCellCount/Automatic-Cell-counting-with-TWS/scripts_for_auto_cell_count/Project N images by ID.R')
